---
title: AI駆動開発の要件定義に含めるべき内容
tags:
  - AI
  - 要件定義
  - AI駆動開発
  - AIエージェント
private: false
updated_at: '2025-05-07T06:22:55+09:00'
id: bb1f41c827d013498ff3
organization_url_name: null
slide: false
ignorePublish: false
---

# 注目され続けるAI駆動開発

## なぜ注目されてる？

近年、生成AIを活用した **「AI駆動型のソフトウェア開発」** が注目されています。

設計・実装・テスト・デプロイ、さらには要件定義まで、すべての工程にAIを活用する…という夢のような開発スタイルです。


![image.png](https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/3780099/c83a1e56-eb36-401b-a94d-adb2cc7d9617.png)




引用：

https://classmethod.jp/news/20250423-aidd/

日系企業もAI駆動を前提にしたソフトウェア開発・アプリ開発を進めています。
またアメリカにはエンジニア経験がないにもかかわらず、ChatGPTとのやりとりだけでアプリを構築し月間60万ドル（約9000万円）稼いだという猛者がいるとか。

参考(ご本人)：

https://x.com/blakeandersonw


きっと良くも悪くも **「開発の民主化」** を進めていることが、AI駆動スタイルの開発が注目されている理由です。


## 「要件定義」は従来のままでいいのか？

しかし、こうしたAI駆動開発が広がる一方で、次のような声も少なくありません。

「期待していたのと違うアプリができた…」

「AIが変なコードを書いて収拾がつかなくなった…」

「結局、人が全部手直ししている…」

なぜ、こんなことが起きるのでしょうか？
その原因は、**「要件定義の軽視」** にあります。

AI駆動開発を行う場合は、AIの特徴を理解したうえで、上記のような失敗を避けられるような対策を盛り込んだ要件定義が必要です。

従来の要件定義だけだと不足する点があることを理解しましょう。

## AI駆動開発を行う上での"危険な思い込み"

AIとの対話を通じて開発が進むため、つい次のような思考に陥りがちです。

- **要件は会話の中で徐々に伝えればいいや**
- **AIの方からそのうち聞いてくるでしょ**

これは、AI開発における**致命的な誤解**です。

従来の開発では、明確な機能要件や画面設計をもとにシステムを構築します。一方、AI開発では「予測」や「分類」といったデータに基づく処理が中心になります。

そのため、開発初期の段階で

- **何がゴールなのか**

- **そのゴールは現実的に達成可能なのか**

をAIが理解できるように定義しておく必要があります。

これを怠ると、どれだけAIが頑張っても、**“それっぽいけど間違ったもの”** ができあがってしまいます。


# 通常の開発とAI駆動開発で最も異なるポイント

## 「決定論的 vs 確率論的」の違い

通常のシステム開発とAI駆動開発で最も異なるポイント、そして理解しておくべき核心的な違いは、「**決定論的 vs 確率論的**」の違いです。


## 通常のシステム開発（決定論的）

* ロジックは**すべて人が明示的に定義**し、仕様通りに動けばOK。
* 「AならBする」「条件Xなら画面Yを出す」といった**ルールベース**。
* 成果物は**再現性が高く、動作が明確**です。

> 📌 例：「会員登録したらメールを送る」→ 必ず送られる。正解 or 不正解がはっきりしている。


## AI駆動開発（確率論的）

* ロジックは**データをもとにAIが学習**する。人が直接コードを書かない部分も多い。
* 出力結果は **確率的な推論（たぶんこうだと思う）** に基づく。
* 成果物は**多少の誤差やブレを含みつつ、全体として「使える」かを問われる**。

> 📌 例：「この文章はスパムかどうか」→ AIが90%の確信で「スパム」と判断。でも10%の誤判定リスクがある。

## 理解すべきこと

上記の違いからAI駆動開発には以下のことを理解しておく必要があります。

* AIは **「完全に正しいもの」を作る技術ではない**。
* **どれくらいの精度でどの業務にどんな影響を与えたいか=「開発のゴール」** を意識して(意識させて)進める必要がある。
* **失敗が起きる前提** で、各フェーズのAIと人間それぞれの役割を考える必要がある。


この違いを理解せずにAI開発に入ると、上で述べたような「いつものシステム開発のノリで進めたけど、思ったより曖昧で難しい…」ということになりがちです。


## ベースは共通

とはいえ、共通点も存在します。

どちらの開発手法においても、「目的を明確にする」「関係者間で認識を揃える」「後からの手戻りを防ぐ」といった基本的な要件定義の役割は変わりません。



# AI駆動開発の要件定義に含めるべき"問い"

上で述べているように、AI駆動開発では従来の「仕様を決めて作る」アプローチとは異なり、「不確実性や試行錯誤を前提にした要件定義」が求められます。

その前提をもとに、**AI駆動開発の要件定義に含めるべき4つの問い** を挙げます。


## 1. Why：なぜAIを使うのか？

**✔ なぜAI駆動開発を採用するのか？**

具体例

1. **開発速度向上のため**
   - 開発者の限られたリソースを最大限に活用するため
   - 反復的なコーディング作業を効率化し、創造的な問題解決に集中するため
   - プロトタイプから製品化までの時間を短縮するため

2. **コード品質向上のため**
   - AIが最新のベストプラクティスを適用したコードを生成するため
   - 一貫性のあるコーディングスタイルとパターンを維持するため
   - 人間が見落としがちなエッジケースや最適化の機会を発見するため

3. **技術的な知識補完のため**
   - 個人開発者が専門外の技術領域を効率的に実装するため
   - 最新のライブラリやフレームワークの活用方法を学習するため
   - 複雑な技術的課題に対する多角的なアプローチを検討するため

4. **イノベーション促進のため**
   - AIとの対話を通じて新しいアイデアや解決策を発見するため
   - 従来の開発手法では思いつかなかった実装方法を模索するため
   - AI駆動開発自体の可能性と限界を探求するため


## 2. What：AIが担うのは何か？

✔ **どの工程をAIに任せるのか？**

✔ **どこに人が関与するのか？**


具体例

1. **AIが担当する領域**
   - コードの生成と実装案の提案
   - 一般的なUIコンポーネントの設計
   - 基本的なテストケースの提案
   - ドキュメントの下書き作成
   - バグ修正案の提示

2. **人間（開発者）が担当する領域**
   - プロジェクトの目的と要件の定義
   - ビジネスロジックの正確性の確認
   - AIが生成したコードのレビューと調整
   - ユーザー体験（UX）の最終判断

3. **AIと人間の協働が必要な領域**
   - アーキテクチャの設計と決定
   - 技術スタックの選定
   - コードの品質とパフォーマンスの最適化
   - ユーザーインターフェースの改善


## 3. How：どう管理・運用するか？

✔ **モデルの更新・再学習の方針は？**

✔ **バージョン・セキュリティ管理の体制は？**


具体例

1. **バージョン管理とコード追跡**
   - すべてのコードはGitHubリポジトリで管理(リポジトリ名)
   - AIが生成したコードは特定のコミットメッセージでマークする（例: "AI-generated: 機能名"　など）
   - 重要な変更点はPRとして管理し、AIの提案と人間の修正を明確に区別
   - コミットメッセージにAIとの対話セッション番号を含めて追跡可能性を確保

2. **品質管理プロセス**
   - AIが生成したコードに対する標準的なレビューチェックリストの作成
   - 自動テストによる基本的な機能検証
   - 定期的なコード品質メトリクスの測定

3. **知識管理と継続的改善**
   - 効果的なプロンプトとAIとの対話パターンのライブラリ化
   - AI駆動開発の成功事例と課題の文書化
   - 開発プロセスの振り返りと改善点の特定

4. **長期的な運用計画**
   - AIツールの進化に合わせた開発プロセスの更新
   - 人間の開発スキルとAI活用スキルの両方を継続的に向上
   - コードベースの一部を定期的にリファクタリングし、技術的負債を管理
   - AIが生成したコードの長期的なメンテナンス性の評価と改善

5. **ドキュメント管理**
   - AIが生成したドキュメントの人間によるレビューと承認プロセス
   - コードとドキュメントの一貫性を確保するための定期的なチェック
   - AIとの対話履歴の保存と重要な決定事項の文書化


## 4. What-if：不確実性/失敗にどう備えるか？

具体例

1. **AIが不正確なコードを生成した場合**
   - 実装前の徹底的なコードレビューを標準プロセスとして設定する
   - エラーパターンのライブラリ化と再発防止策の文書化

2. **AIが最新の技術情報を持っていない場合**
   - AIの知識カットオフ日を常に意識した開発計画
   - 技術スタックの選定時に安定性と成熟度を重視

3. **AIが複雑な要件を誤解した場合**
   - 要件を小さな単位に分割して段階的に指示
   - 具体的な例やユースケースを含めた明確な指示

4. **AIが生成したコードにセキュリティ脆弱性がある場合**
   - OWASP Top 10などのセキュリティチェックリストの活用
   - 認証・認可・データ処理部分の特に慎重なレビュー

5. **AIが一貫性のない設計を提案した場合**
   - 定期的な全体設計レビューの実施
   - コンポーネント間の依存関係の可視化と管理
   - 技術的負債の早期発見と計画的な解消

# 実際に上記を意識した上でAI駆動個人開発をしてみた

以上を意識した要件定義を作成し、AI駆動ツールのv0を使用し「リアルタイムアンケートサイト」の開発を行ってみました。要件定義を上手く作成できたおかげで、欲しいものをスムーズに最低限のコストで開発できたと思います。


https://v0.dev/



<iframe width="560" height="315" src="https://www.youtube-nocookie.com/embed/3j-Zgoxjtks?si=XCKfuWNyirJrxZGL" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

「オンライン上で、セミナーや発表があった際にアンケートの結果がリアルタイムで見れるサイトがあれば、いろんなメリットがあるのでは？」と思い作成してみました。デプロイまで行っているのですが、ユーザー登録などは搭載していないため、URLは公開していません。これはこれで別途記事にしようと思っています。




<details><summary>こちら作成した要件定義(長いため折りたたみ)</summary>

```
# リアルタイムアンケートシステム 要件定義書

## 1. 目的と概要

### 1.1 目的
本システムは、プレゼンテーションやミーティング中に参加者からフィードバックをリアルタイムで収集し、視覚化するためのウェブアプリケーションを提供することを目的とする。
Teams や Zoom などのビデオ会議ツールと併用して使用することを想定している。

### 1.2 概要
プレゼンター（発表者）は画面の左半分にアンケート質問と回答結果をリアルタイムで表示し、右半分にはQRコードを表示する。
参加者はQRコードをスキャンしてアンケートに回答し、その結果がリアルタイムでプレゼンターの画面に反映される。

### 1.3 開発アプローチ
本システムは、AI駆動開発（AI-Driven Development）アプローチを採用している。具体的には、Vercelが提供するAIアシスタント「v0」と個人開発者の協働により開発を進める。このアプローチにより、開発効率の向上と高品質なコード生成を実現する。

## 2. 機能要件

### 2.1 基本機能
- アンケート表示機能: 質問と回答結果を表示する画面
- 回答入力機能: 参加者が回答を入力する画面
- QRコード生成機能: アンケート回答ページへのアクセス用QRコードの生成
- リアルタイム更新機能: 回答がリアルタイムで集計・表示される機能
- 管理者機能: アンケートの作成・編集・管理機能

### 2.2 質問タイプ
- 選択式質問: 複数の選択肢から一つを選ぶ形式
- テキスト入力質問: 自由記述形式
- 評価質問: 1〜5段階で評価する形式

### 2.3 画面構成
- メイン画面（プレゼンター用）:
  - 左側2/3: 質問表示と回答結果のグラフ表示
  - 右側1/3: QRコードと管理者リンク
- 回答画面（参加者用）:
  - アンケートタイトルと説明
  - 質問と回答入力フォーム
  - 送信ボタン
- 管理者画面:
  - アンケートタイトル・説明の編集
  - 質問の追加・編集・削除
  - 回答のリセット

### 2.4 データ管理
- アンケートタイトルと説明の保存
- 質問内容と選択肢の保存
- 回答データの収集と集計
- 回答データのリアルタイム更新

## 3. 非機能要件

### 3.1 パフォーマンス
- 回答送信から表示更新までの遅延は2秒以内
- 同時に最大100人の参加者が回答できること
- 画面の読み込み時間は3秒以内

### 3.2 セキュリティ
- 管理者画面へのアクセス制限（将来的に実装）
- データの改ざん防止

### 3.3 可用性
- システムの稼働率は99.5%以上
- 計画的なメンテナンス以外でのダウンタイムは最小限に抑える

### 3.4 ユーザビリティ
- 直感的で使いやすいUI/UX
- レスポンシブデザインによる様々なデバイスへの対応
- アクセシビリティへの配慮

### 3.5 拡張性
- 将来的な機能追加が容易な設計
- データベース連携が可能な構造

## 4. ユーザーストーリー

### 4.1 プレゼンター（発表者）
- プレゼンターとして、アンケートを作成・編集したい
- プレゼンターとして、参加者の回答をリアルタイムで確認したい
- プレゼンターとして、アンケート結果をグラフで視覚的に把握したい
- プレゼンターとして、質問を切り替えて表示したい
- プレゼンターとして、必要に応じて回答データをリセットしたい

### 4.2 参加者
- 参加者として、QRコードをスキャンして簡単にアンケートにアクセスしたい
- 参加者として、質問に対して簡単に回答したい
- 参加者として、回答が正常に送信されたことを確認したい
- 参加者として、複数の質問に連続して回答したい

## 5. 技術要件

### 5.1 フロントエンド
- Next.js 15を使用したReactアプリケーション
- Tailwind CSSによるスタイリング
- shadcn/uiコンポーネントライブラリの活用
- Rechartsによるデータ可視化
- QRCode.reactによるQRコード生成
- Zustandによる状態管理

### 5.2 バックエンド
- Next.js Server Actionsによるサーバーサイドロジック
- 初期段階ではインメモリデータストレージを使用
- 将来的にはデータベース連携を想定

### 5.3 通信
- 初期段階ではポーリングによるデータ更新（2秒間隔）
- 将来的にはWebSocketによるリアルタイム通信を想定

## 6. AI駆動開発（AI-Driven Development）

### 6.1 Why：なぜAIを使うのか？
本プロジェクトでAI駆動開発を採用する理由は以下の通りである：

1. **開発速度の向上**：
   - 個人開発者の限られたリソースを最大限に活用するため
   - 反復的なコーディング作業を効率化し、創造的な問題解決に集中するため
   - プロトタイプから製品化までの時間を短縮するため

2. **コード品質の向上**：
   - AIが最新のベストプラクティスを適用したコードを生成するため
   - 一貫性のあるコーディングスタイルとパターンを維持するため
   - 人間が見落としがちなエッジケースや最適化の機会を発見するため

3. **技術的な知識の補完**：
   - 個人開発者が専門外の技術領域（例：データ可視化、リアルタイム通信）を効率的に実装するため
   - 最新のライブラリやフレームワークの活用方法を学習するため
   - 複雑な技術的課題に対する多角的なアプローチを検討するため

4. **イノベーションの促進**：
   - AIとの対話を通じて新しいアイデアや解決策を発見するため
   - 従来の開発手法では思いつかなかった実装方法を模索するため
   - AI駆動開発自体の可能性と限界を探求するため

### 6.2 What：何をAIが担うのか？
AIと人間の役割分担を明確にし、それぞれの強みを活かした開発プロセスを構築する：

1. **AIが担当する領域**：
   - コードの生成と実装案の提案
   - 一般的なUIコンポーネントの設計
   - データモデルとAPIの設計
   - エラーハンドリングとバリデーションロジックの実装
   - 基本的なテストケースの提案
   - ドキュメントの下書き作成
   - バグ修正案の提示
   - パフォーマンス最適化の提案

2. **人間（開発者）が担当する領域**：
   - プロジェクトの目的と要件の定義
   - ビジネスロジックの正確性の確認
   - AIが生成したコードのレビューと調整
   - ユーザー体験（UX）の最終判断
   - セキュリティ関連の実装の検証
   - 最終的なテスト戦略の決定
   - デプロイと運用の管理
   - ユーザーフィードバックに基づく改善判断

3. **協働が必要な領域**：
   - アーキテクチャの設計と決定
   - 技術スタックの選定
   - コードの品質とパフォーマンスの最適化
   - 複雑なビジネスロジックの実装
   - エッジケースの特定と対応
   - ユーザーインターフェースの改善
   - 技術的負債の管理

4. **AIから人間への移行ポイント**：
   - 生成されたコードが期待通りに動作しない場合
   - ビジネスロジックが複雑で文脈理解が必要な場合
   - セキュリティに関わる重要な実装の場合
   - パフォーマンスが要件を満たさない場合
   - ユーザー体験に関する主観的な判断が必要な場合
   - 倫理的な判断や法的考慮が必要な場合

### 6.3 How：どのように管理するのか？
AI駆動開発プロセスの管理方法と今後の運用計画：

1. **バージョン管理とコード追跡**：
   - すべてのコードはGitHubリポジトリで管理（setowatson/Realtime_Questionnaire）
   - AIが生成したコードは特定のコミットメッセージでマーク（例: "AI-generated: 機能名"）
   - 重要な変更点はPRとして管理し、AIの提案と人間の修正を明確に区別
   - コミットメッセージにAIとの対話セッション番号を含めて追跡可能性を確保

2. **品質管理プロセス**：
   - AIが生成したコードに対する標準的なレビューチェックリストの作成
   - 自動テストによる基本的な機能検証
   - 定期的なコード品質メトリクスの測定（複雑性、重複、テストカバレッジ）
   - セキュリティスキャンツールによる定期的な検証

3. **知識管理と継続的改善**：
   - 効果的なプロンプトとAIとの対話パターンのライブラリ化
   - AI駆動開発の成功事例と課題の文書化
   - 開発プロセスの振り返りと改善点の特定
   - AIの能力と限界に関する知見の蓄積

4. **長期的な運用計画**：
   - AIツールの進化に合わせた開発プロセスの更新
   - 人間の開発スキルとAI活用スキルの両方を継続的に向上
   - コードベースの一部を定期的にリファクタリングし、技術的負債を管理
   - AIが生成したコードの長期的なメンテナンス性の評価と改善

5. **ドキュメント管理**：
   - AIが生成したドキュメントの人間によるレビューと承認プロセス
   - コードとドキュメントの一貫性を確保するための定期的なチェック
   - AIとの対話履歴の保存と重要な決定事項の文書化
   - 開発プロセスとAI活用のベストプラクティスの継続的な更新

### 6.4 What-if：生成AIの不確実性/失敗にどう備えるか？
AI駆動開発における不確実性や失敗に対する備えと対応策：

1. **AIが不正確なコードを生成した場合**：
   - 実装前の徹底的なコードレビューを標準プロセスとして確立
   - 自動テストによる機能検証の徹底（単体テスト、統合テスト）
   - 段階的な実装とテストによる早期の問題発見
   - エラーパターンのライブラリ化と再発防止策の文書化

2. **AIが最新の技術情報を持っていない場合**：
   - AIの知識カットオフ日（2023年）を常に意識した開発計画
   - 最新技術に関しては公式ドキュメントを優先的に参照
   - 技術スタックの選定時に安定性と成熟度を重視
   - 開発者による最新技術トレンドの定期的な調査と補完

3. **AIが複雑な要件を誤解した場合**：
   - 要件を小さな単位に分割して段階的に指示
   - 具体的な例やユースケースを含めた明確な指示
   - 生成されたコードと要件の一致を確認するチェックリストの活用
   - 複雑な要件は図表やフローチャートで視覚化して伝達

4. **AIが生成したコードにセキュリティ脆弱性がある場合**：
   - セキュリティスキャンツールによる定期的な検証
   - OWASP Top 10などのセキュリティチェックリストの活用
   - 認証・認可・データ処理部分の特に慎重なレビュー
   - 外部からの入力データに対する徹底的なバリデーション

5. **AIが一貫性のない設計を提案した場合**：
   - アーキテクチャ設計原則とパターンの事前定義
   - 定期的な全体設計レビューの実施
   - コンポーネント間の依存関係の可視化と管理
   - 技術的負債の早期発見と計画的な解消

6. **AIの応答が遅い、または利用できない場合**：
   - 重要なコードセグメントのテンプレートやスニペットのローカル保存
   - 代替のAIツールや開発リソースの確保
   - クリティカルな開発タスクの優先順位付けと時間管理
   - 手動での実装に切り替えるための明確な判断基準の設定

7. **AIが提案した実装が性能要件を満たさない場合**：
   - パフォーマンス要件の明確な定義と測定方法の確立
   - 早期からのパフォーマンステストの実施
   - ボトルネックの特定と最適化のための専門知識の活用
   - 段階的な負荷テストによる性能検証

8. **AIが生成したコードの保守性が低い場合**：
   - コード品質メトリクス（複雑度、結合度など）の定期的な測定
   - リファクタリングのためのタイムボックスの計画的な確保
   - コーディング規約とベストプラクティスの文書化と遵守
   - コードの自己文書化（適切な命名、コメント）の徹底

これらの対策を事前に計画し、AI駆動開発の不確実性に備えることで、プロジェクトの成功確率を高め、リスクを最小化する。また、発生した問題と解決策を記録することで、将来のAI駆動プロジェクトにおける知見として活用する。

### 6.5 AI駆動開発のプロセス
1. 開発者がAIに機能要件を提示
2. AIがコード生成と実装案を提案
3. 開発者がコードをレビューし、必要に応じて調整
4. 開発者とAIの対話を通じて機能を改善・拡張
5. 開発者による最終確認とデプロイ

### 6.6 AI駆動開発の利点
- 開発速度の向上: AIによる迅速なコード生成
- コード品質の向上: AIが最新のベストプラクティスを適用
- 学習と知識共有: 開発者がAIとの対話を通じて新技術を学習
- 柔軟な開発: 要件変更に対する迅速な対応

### 6.7 AI駆動開発における課題と対策
- コード品質の確保: 開発者によるレビューと品質チェック
- セキュリティリスク: AIが生成したコードのセキュリティレビュー
- 責任の所在: 最終的な判断と責任は開発者が持つ
- 依存性の管理: AIが提案するライブラリの適切な選定

## 7. 制約条件

### 7.1 技術的制約
- サーバーレス環境での動作を前提とする
- 初期段階ではデータの永続化は行わない（サーバー再起動でデータは消失）
- ブラウザの互換性はモダンブラウザ（Chrome, Firefox, Safari, Edge最新版）のみ保証

### 7.2 ビジネス制約
- 初期開発期間は2週間以内
- 最小限の機能で早期にリリースし、フィードバックを得ながら改善する

### 7.3 AI駆動開発における制約
- AIの提案するコードは常に人間のレビューを経る
- AIの知識の限界（2023年までの情報）を考慮した開発計画
- AIが生成したコードの著作権と利用規約の遵守
- AIへの過度な依存を避け、開発者のスキル維持を重視

## 8. 将来の拡張性

### 8.1 短期的な拡張（3ヶ月以内）
- データベース連携（MongoDB, PostgreSQL, Supabaseなど）
- 管理者認証機能
- 回答データのエクスポート機能（CSV, Excel）

### 8.2 中長期的な拡張（6ヶ月〜1年）
- WebSocketによるリアルタイム通信
- 複数アンケートの管理機能
- 回答の詳細分析機能
- カスタムテーマ設定
- 質問タイプの追加（画像選択、スライダーなど）

### 8.3 AI活用の将来展望
- AIによる回答データの自動分析と洞察の提供
- AIを活用したアンケート質問の自動生成・最適化
- 自然言語処理によるテキスト回答の感情分析
- AIによるUIの自動最適化
- AIを活用した回答予測と傾向分析

## 9. 開発・テスト環境

### 9.1 開発環境
- Node.js 18.0.0以上
- npm, yarn, またはpnpm
- Git
- Vercel AI（v0）との連携環境

### 9.2 テスト環境
- Jest, React Testing Libraryによる単体テスト
- Cypress, Playwright によるE2Eテスト（将来的に実装）

### 9.3 デプロイ環境
- Vercelによるホスティング
- GitHub連携によるCI/CD

## 10. プロジェクト管理

### 10.1 開発フェーズ
1. 要件定義・設計フェーズ（AI協働）
2. 基本機能実装フェーズ（AI主導コード生成）
3. UI/UX改善フェーズ（開発者とAIの協働）
4. テスト・バグ修正フェーズ（AI支援によるデバッグ）
5. リリース・フィードバック収集フェーズ

### 10.2 優先順位
1. メイン画面と回答画面の基本機能
2. リアルタイム更新機能
3. 管理者機能
4. UI/UX改善
5. 拡張機能

### 10.3 AI駆動開発のイテレーション
- 短いイテレーションサイクル（1-3日）
- 各機能ごとにAIとの対話セッションを設定
- 定期的なコードレビューと改善

## 11. リスク管理

### 11.1 技術的リスク
- リアルタイム更新の遅延が大きくなる可能性
  - 対策: ポーリング間隔の最適化、将来的にWebSocketへの移行
- 多数の同時アクセスによるパフォーマンス低下
  - 対策: 負荷テストの実施、スケーラブルな設計

### 11.2 プロジェクト管理リスク
- 要件の変更や追加による開発遅延
  - 対策: アジャイル開発手法の採用、MVPの明確化
- リソース不足
  - 対策: 優先順位の明確化、フェーズ分けによる段階的開発

### 11.3 AI駆動開発特有のリスク
- AIが生成したコードの品質や最適性の問題
  - 対策: 人間によるコードレビュー、テストカバレッジの向上
- AIの知識の限界や誤解
  - 対策: 明確な指示と要件の提示、結果の検証
- AIへの過度な依存
  - 対策: 開発者のスキル維持、重要な判断は人間が行う
- AIの提案の一貫性の欠如
  - 対策: 設計原則とアーキテクチャの文書化、定期的な全体レビュー

## 12. 用語集

- **プレゼンター**: アンケートを作成・管理し、結果を表示する側のユーザー
- **参加者**: アンケートに回答する側のユーザー
- **リアルタイム更新**: 回答がほぼ即時に集計結果に反映される機能
- **ポーリング**: 定期的にサーバーにデータを問い合わせる方式
- **WebSocket**: 双方向通信を可能にするプロトコル
- **QRコード**: スマートフォンなどで読み取り可能な二次元バーコード
- **AI駆動開発**: AIと人間の開発者が協働してソフトウェアを開発するアプローチ
- **v0**: Vercelが提供するAIアシスタント

## 13. AI駆動開発の成果と学び

### 13.1 開発プロセスの記録
本プロジェクトでは、AI駆動開発の過程を記録し、その効果と課題を分析する。これにより、将来のプロジェクトにおけるAI活用の改善に役立てる。

### 13.2 知識の共有
AI駆動開発を通じて得られた知見や学びを、開発コミュニティと共有する。これにより、AIと人間の協働による開発手法の発展に貢献する。

## 14. 承認

本要件定義書は、プロジェクト開発者によって確認され、承認されるものとする。
要件の変更が必要な場合は、開発者とAIアシスタントの協議により更新する。
```


</details>


# まとめ：AI駆動開発と向き合うために

AI駆動開発は、ソフトウェア開発のあり方を根本から変える可能性を持っています。開発の民主化、スピードの向上、知識の補完など多くのメリットがある一方で、**「確率論的であること」** や **「AIの限界」** を正しく理解しないまま進めると、思わぬ落とし穴にハマるリスクもあります。

その中でも特に重要なのが、**要件定義**です。

従来の開発以上に、AI駆動開発では、

* **なぜAIを使うのか（Why）**
* **どの部分をAIに任せるのか（What）**
* **どのように管理・運用するのか（How）**
* **うまくいかなかったときどうするか（What-if）**

という問いを明確にし、開発の目的・ゴール・期待値をはじめにしっかりと定義することが、プロジェクト成功の鍵となります。

AIは万能ではなく、正しく導くことで初めて力を発揮します。だからこそ、**人間の役割＝問いを立てる力** がますます重要になっていくのかもしれません。




