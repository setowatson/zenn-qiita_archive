---
title: "AI駆動開発に要件定義は必要か。"
emoji: "🌱"
type: "idea" # tech: 技術記事 / idea: アイデア
topics: ["ai", "プロンプトエンジニアリング", "個人開発", "AI駆動開発"]
published: false
---

# AI駆動開発にも要件定義は必要？

## 注目され続けるAI駆動開発

近年、生成AIを活用した **「AI駆動型のソフトウェア開発」** が注目されています。

要件定義や設計はもちろん開発以外のテストやデプロイなど、すべてのフェーズにおいて生成AIを活用する開発手法・思想です。

アメリカにはエンジニアのバックグラウンドがないにもかかわらず、ChatGPTとのやりとりだけでアプリを構築し月間60万ドル（約9000万円）稼いだというとんでもない男性がいるとか。

https://x.com/blakeandersonw

## 「まずは要件定義を書こう」？

ではそのAI駆動型開発を行うとして、まずは「要件定義を作ろう！」と言わています。
ソフトウェア開発としては当たり前ですね。


https://zenn.dev/yasuna/articles/9dadbcdc3be48d


https://x.com/masa_oka108/status/1911617822037614753?s=61


ただし、この当たり前のように行なっている要件定義、AI駆動開発の際にはどれほどの必要性を持つのでしょうか。
もちろん、要件定義のない開発は「」「」


## そもそもの要件定義の目的

ここでそもそものシステム開発の要件定義に求められることを整理します。
IPAのガイドには以下の表記がありました。

> 1. 経営や業務に貢献する要求を見極める
> 2. 要求を実現する新しい業務を作り上げる
> 3. 要求仕様を「抜け」「漏れ」「あいまい」なくシステム開発につなげる
> - ポイント①：【請負】瑕疵担保責任の改正
> - ポイント②：【請負】プロジェクトがとん挫した場合でも報酬請求が可能に
> - ポイント③：【準委任】成果完成型の準委任契約が認められた


引用：ユーザのための要件定義ガイド第2版 要件定義を成功に導く 128 の勘どころ

https://www.ipa.go.jp/archive/publish/qv6pgp0000000wrt-att/000079352.pdf


# 実験：要件定義の違いによってどれだけQCDが異なるか。

以下の3つのアプローチで実験を行い、QCD（Quality, Cost, Delivery）の観点から比較検証します。


1. 直接プロンプト
2. 段階的プロンプト
3. 完成済みの要件定義のプロンプト

## 開発対象の説明

本実験では、シンプルなタスク管理アプリケーションを開発対象としました。

具体的な機能要件は以下の通りです。

- タスクの作成、編集、削除
- タスクのステータス管理（未着手、進行中、完了）
- タスクの優先度設定
- タスクの検索・フィルタリング機能
- ユーザー認証機能
- データの永続化（データベース連携）

## 使用したAI

本実験では、以下のAIツールを使用しました：

- **ChatGPT 4.0**
  - 最新のGPT-4モデルを使用
  - コード生成、レビュー、デバッグ支援
  - プロンプトの最適化支援

- **GitHub Copilot**
  - リアルタイムのコード補完
  - コンテキストに基づく提案
  - 既存コードの理解と改善提案

## プロンプトの3レベル

実験では、以下の3つのレベルのプロンプトを使用しました：

### レベル1：1文のみのざっくり要望
- 特徴：最小限の情報のみを提供
- 例：「

```
会議とかプレゼン中に、参加者がスマホからリアルタイムでアンケートに答えられるWebアプリを作るよ。
発表者は事前にアンケートを作っておいて、当日はQRコードで共有すればOK。
参加者はインストールとか登録なしで、そのまま回答できる。
集まった結果はその場で画面に表示されて、発表者も参加者もすぐに反応を見られるようにする。
```

### レベル2：意図や背景は説明するが技術要件はふわっと

- 特徴：目的や背景は説明するが、具体的な技術要件は指定しない
- 例：

```
## 目的
会議やプレゼンテーション中に、参加者がスマートフォンから簡単にリアルタイムでアンケートに答えられるWebアプリを作成する。発表者は事前にアンケートを作成し、当日はQRコードを使って参加者に共有し、アンケートに簡単にアクセスできるようにする。集まった回答はその場でリアルタイムで集計され、発表者や参加者が即座に結果を確認できる。

## 背景
現在、会議やプレゼンでの参加者の意見を迅速に集める手段が限られており、フィードバックを得るタイミングや方法に手間がかかることが多い。アンケートツールの活用は有効だが、参加者がインストールや登録なしで参加できるシンプルなものが求められている。さらに、集計結果がその場で表示され、参加者や発表者がすぐに反応できるような形が理想である。

## 特徴
* **シンプルなアクセス**：参加者はQRコードをスキャンすることで、インストールやログインなしでそのままアンケートに回答可能。
* **リアルタイム集計**：回答が集まり次第、結果がその場で発表者や参加者に表示され、反応が得られる。
* **フレキシビリティ**：発表者が事前にアンケート内容を設定し、会議中に柔軟に対応できる。
```

### レベル3：要件定義としてまとめた指示書レベル
- 特徴：詳細な要件定義書形式で指示
- 例：

:::details 要件定義書

```
# リアルタイムアンケートシステム 要件定義書

## 1. 目的と概要

### 1.1 目的
本システムは、プレゼンテーションやミーティング中に参加者からフィードバックをリアルタイムで収集し、視覚化するためのウェブアプリケーションを提供することを目的とする。
Teams や Zoom などのビデオ会議ツールと併用して使用することを想定している。

### 1.2 概要
プレゼンター（発表者）は画面の左半分にアンケート質問と回答結果をリアルタイムで表示し、右半分にはQRコードを表示する。
参加者はQRコードをスキャンしてアンケートに回答し、その結果がリアルタイムでプレゼンターの画面に反映される。

### 1.3 開発アプローチ
本システムは、AI駆動開発（AI-Driven Development）アプローチを採用している。具体的には、Vercelが提供するAIアシスタント「v0」と個人開発者の協働により開発を進める。このアプローチにより、開発効率の向上と高品質なコード生成を実現する。

## 2. 機能要件

### 2.1 基本機能
- アンケート表示機能: 質問と回答結果を表示する画面
- 回答入力機能: 参加者が回答を入力する画面
- QRコード生成機能: アンケート回答ページへのアクセス用QRコードの生成
- リアルタイム更新機能: 回答がリアルタイムで集計・表示される機能
- 管理者機能: アンケートの作成・編集・管理機能

### 2.2 質問タイプ
- 選択式質問: 複数の選択肢から一つを選ぶ形式
- テキスト入力質問: 自由記述形式
- 評価質問: 1〜5段階で評価する形式

### 2.3 画面構成
- メイン画面（プレゼンター用）:
  - 左側2/3: 質問表示と回答結果のグラフ表示
  - 右側1/3: QRコードと管理者リンク
- 回答画面（参加者用）:
  - アンケートタイトルと説明
  - 質問と回答入力フォーム
  - 送信ボタン
- 管理者画面:
  - アンケートタイトル・説明の編集
  - 質問の追加・編集・削除
  - 回答のリセット

### 2.4 データ管理
- アンケートタイトルと説明の保存
- 質問内容と選択肢の保存
- 回答データの収集と集計
- 回答データのリアルタイム更新

## 3. 非機能要件

### 3.1 パフォーマンス
- 回答送信から表示更新までの遅延は2秒以内
- 同時に最大100人の参加者が回答できること
- 画面の読み込み時間は3秒以内

### 3.2 セキュリティ
- 管理者画面へのアクセス制限（将来的に実装）
- データの改ざん防止

### 3.3 可用性
- システムの稼働率は99.5%以上
- 計画的なメンテナンス以外でのダウンタイムは最小限に抑える

### 3.4 ユーザビリティ
- 直感的で使いやすいUI/UX
- レスポンシブデザインによる様々なデバイスへの対応
- アクセシビリティへの配慮

### 3.5 拡張性
- 将来的な機能追加��容易な設計
- データベース連携が可能な構造

## 4. ユーザーストーリー

### 4.1 プレゼンター（発表者）
- プレゼンターとして、アンケートを作成・編集したい
- プレゼンターとして、参加者の回答をリアルタイムで確認したい
- プレゼンターとして、アンケート結果をグラフで視覚的に把握したい
- プレゼンターとして、質問を切り替えて表示したい
- プレゼンターとして、必要に応じて回答データをリセットしたい

### 4.2 参加者
- 参加者として、QRコードをスキャンして簡単にアンケートにアクセスしたい
- 参加者として、質問に対して簡単に回答したい
- 参加者として、回答が正常に送信されたことを確認したい
- 参加者として、複数の質問に連続して回答したい

## 5. 技術要件

### 5.1 フロントエンド
- Next.js 15を使用したReactアプリケーション
- Tailwind CSSによるスタイリング
- shadcn/uiコンポーネントライブラリの活用
- Rechartsによるデータ可視化
- QRCode.reactによるQRコード生成
- Zustandによる状態管理

### 5.2 バックエンド
- Next.js Server Actionsによるサーバーサイドロジック
- 初期段階ではインメモリデータストレージを使用
- 将来的にはデータベース連携を想定

### 5.3 通信
- 初期段階ではポーリングによるデータ更新（2秒間隔）
- 将来的にはWebSocketによるリアルタイム通信を想定

## 6. AI駆動開発（AI-Driven Development）

### 6.1 AI駆動開発の概要
本プロジェクトは、Vercelが提供するAIアシスタント「v0」と個人開発者の協働により開発を進める。AIが提案するコードを開発者がレビュー・調整することで、効率的かつ高品質な開発を実現する。

### 6.2 AI駆動開発のプロセス
1. 開発者がAIに機能要件を提示
2. AIがコード生成と実装案を提案
3. 開発者がコードをレビューし、必要に応じて調整
4. 開発者とAIの対話を通じて機能を改善・拡張
5. 開発者による最終確認とデプロイ

### 6.3 AI駆動開発の利点
- 開発速度の向上: AIによる迅速なコード生成
- コード品質の向上: AIが最新のベストプラクティスを適用
- 学習と知識共有: 開発者がAIとの対話を通じて新技術を学習
- 柔軟な開発: 要件変更に対する迅速な対応

### 6.4 AI駆動開発における課題と対策
- コード品質の確保: 開発者によるレビューと品質チェック
- セキュリティリスク: AIが生成したコードのセキュリティレビュー
- 責任の所在: 最終的な判断と責任は開発者が持つ
- 依存性の管理: AIが提案するライブラリの適切な選定

### 6.5 AI駆動開発における役割分担
- AI（v0）の役割:
  - コード生成と実装案の提案
  - 技術的な質問への回答
  - ベストプラクティスの提案
  - バグ修正案の提示
- 開発者の役割:
  - 要件定義と機能仕様の決定
  - AIが生成したコードのレビューと調整
  - ビジネスロジックの確認
  - 最終的な判断と責任

## 7. 制約条件

### 7.1 技術的制約
- サーバーレス環境での動作を前提とする
- 初期段階ではデータの永続化は行わない（サーバー再起動でデータは消失）
- ブラウザの互換性はモダンブラウザ（Chrome, Firefox, Safari, Edge最新版）のみ保証

### 7.2 ビジネス制約
- 初期開発期間は2週間以内
- 最小限の機能で早期にリリースし、フィードバックを得ながら改善する

### 7.3 AI駆動開発における制約
- AIの提案するコードは常に人間のレビューを経る
- AIの知識の限界（2023年までの情報）を考慮した開発計画
- AIが生成したコードの著作権と利用規約の遵守

## 8. 将来の拡張性

### 8.1 短期的な拡張（3ヶ月以内）
- データベース連携（MongoDB, PostgreSQL, Supabaseなど）
- 管理者認証機能
- 回答データのエクスポート機能（CSV, Excel）

### 8.2 中長期的な拡張（6ヶ月〜1年）
- WebSocketによるリアルタイム通信
- 複数アンケートの管理機能
- 回答の詳細分析機能
- カスタムテーマ設定
- 質問タイプの追加（画像選択、スライダーなど）

### 8.3 AI活用の将来展望
- AIによる回答データの自動分析と洞察の提供
- AIを活用したアンケート質問の自動生成・最適化
- 自然言語処理によるテキスト回答の感情分析
- AIによるUIの自動最適化

## 9. 開発・テスト環境

### 9.1 開発環境
- Node.js 18.0.0以上
- npm, yarn, またはpnpm
- Git
- Vercel AI（v0）との連携環境

### 9.2 テスト環境
- Jest, React Testing Libraryによる単体テスト
- Cypress, Playwright によるE2Eテスト（将来的に実装）

### 9.3 デプロイ環境
- Vercelによるホスティング
- GitHub連携によるCI/CD

## 10. プロジェクト管理

### 10.1 開発フェーズ
1. 要件定義・設計フェーズ（AI協働）
2. 基本機能実装フェーズ（AI主導コード生成）
3. UI/UX改善フェーズ（開発者とAIの協働）
4. テスト・バグ修正フェーズ（AI支援によるデバッグ）
5. リリース・フィードバック収集フェーズ

### 10.2 優先順位
1. メイン画面と回答画面の基本機能
2. リアルタイム更新機能
3. 管理者機能
4. UI/UX改善
5. 拡張機能

### 10.3 AI駆動開発のイテレーション
- 短いイテレーションサイクル（1-3日）
- 各機能ごとにAIとの対話セッションを設定
- 定期的なコードレビューと改善

## 11. リスク管理

### 11.1 技術的リスク
- リアルタイム更新の遅延が大きくなる可能性
  - 対策: ポーリング間隔の最適化、将来的にWebSocketへの移行
- 多数の同時アクセスによるパフォーマンス低下
  - 対策: 負荷テストの実施、スケーラブルな設計

### 11.2 プロジェクト管理リスク
- 要件の変更や追加による開発遅延
  - 対策: アジャイル開発手法の採用、MVPの明確化
- リソース不足
  - 対策: 優先順位の明確化、フェーズ分けによる段階的開発

### 11.3 AI駆動開発特有のリスク
- AIが生成したコードの品質や最適性の問題
  - 対策: 人間によるコードレビュー、テストカバレッジの向上
- AIの知識の限界や誤解
  - 対策: 明確な指示と要件の提示、結果の検証
- AIへの過度な依存
  - 対策: 開発者のスキル維持、重要な判断は人間が行う

## 12. 用語集

- **プレゼンター**: アンケートを作成・管理し、結果を表示する側のユーザー
- **参加者**: アンケートに回答する側のユーザー
- **リアルタイム更新**: 回答がほぼ即時に集計結果に反映される機能
- **ポーリング**: 定期的にサーバーにデータを問い合わせる方式
- **WebSocket**: 双方向通信を可能にするプロトコル
- **QRコード**: スマートフォンなどで読み取り可能な二次元バーコード
- **AI駆動開発**: AIと人間の開発者が協働してソフトウェアを開発するアプローチ
- **v0**: Vercelが提供するAIアシスタント


## 13. 承認

本要件定義書は、プロジェクト開発者によって確認され、承認されるものとする。
要件の変更が必要な場合は、開発者とAIアシスタントの協議により更新する。
```

:::

# 実験環境

## 使用ツール
- ChatGPT 4.0
- GitHub Copilot
- ローカル開発環境

## 対象プロジェクト
- シンプルなWebアプリケーション
- データベース連携機能
- ユーザー認証機能

# 実験方法

## 1. 直接プロンプト
- 要件定義なしで直接開発を依頼
- プロンプト例：「Webアプリを作ってください」

## 2. 段階的プロンプト
- 要件を段階的に追加
- プロンプト例：
  1. 「基本的な機能を実装してください」
  2. 「データベース連携を追加してください」
  3. 「ユーザー認証を実装してください」

## 3. 要件定義ありのプロンプト
- 詳細な要件定義書を作成
- 要件に基づいて開発を依頼

# 評価基準

## Quality（品質）
- コードの品質
- バグの発生率
- 保守性

## Cost（コスト）
- 開発時間
- 修正回数
- リソース使用量

## Delivery（納期）
- 実装完了までの時間
- デプロイまでの時間
- 修正対応時間

# 実験結果

## 直接プロンプト
- 結果概要
- メリット
- デメリット
- QCD評価

## 段階的プロンプト
- 結果概要
- メリット
- デメリット
- QCD評価

## 要件定義ありのプロンプト
- 結果概要
- メリット
- デメリット
- QCD評価

# 考察

## 各アプローチの比較
- 品質面での比較
- コスト面での比較
- 納期面での比較

## 実践的な活用方法
- プロジェクト規模による選択基準
- チーム体制による選択基準
- リスク管理の観点

# 結論

- 実験結果の総括
- 実践的な提言
- 今後の展望

# 参考資料

- [プロンプトエンジニアリングの基礎](https://example.com)
- [AIを活用したソフトウェア開発](https://example.com)
- [要件定義の重要性](https://example.com) 